#!/usr/bin/sh
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
#@ 					Current version: 1.2.3													@
#@					Last update: 01/12/2008													@
#@ 				Last person to update: Gerardo Stola	 						@
#@																													@
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# 1.2.2: Se vuelve a procesar como antes: Tarjeta DIN, Tarjeta ABC, Cliente DIN y Cliente ABC
# 1.2.3: Los archivos Feedback_Cliente se renombran a .processed, para que se procesen solo una vez.
###################################################################################################################
############################################# Start of help #######################################################
###################################################################################################################

######################################### Basic configuration #####################################################
#Below, we define some mandatory data for running the script
#DIR_SYSTEM_GEN=(TEXT)
#	-> Fixed part of the base dir of ProbeSM system. It excludes the index automatically appended to the end. Typically 
#		 it will be "/probesm/System"
#
#export ODBCINI=(TEXT)
#	-> Full name of the odbc initialization file
#
#export PROBESM_CONF_FILE=(TEXT)
#	-> Full name of the Probe SM configuration XML files
#
#export TRACE=(NUMERIC)
#	-> Enables or disbles the tracing
#
#SYS_NAME=(TEXT)
# -> Name of system file, not including any extension (tgt/cdf) 
#
#DateFile=(TEXT)
#	-> Full name to an optional file containing the process date, in case no parameters is passed to the script
#
##################################### End of basic configuration ##################################################

###################################### Begin of concurrency configuration #########################################
#Below, we define how many threads and simultaneous processes will run in parallel
#THREAD=(NUMERIC)
#	-> Amount of threads per process
#
#Parallel_count=(NUMERIC)
#	-> Amount of processes to execute in parallel
#
################################### End of concurrency configuration ##############################################

#########################################  Begin of context declaration ###########################################
#Below, we declare every context that will run in the ProbeSM system.
#Context_count=(NUMERIC) 
#	-> Declares how many contexts will exist in the system, regardless of the processing date
#
#Now we are to define several arrays for specific context customization. The dimension of the arrays is equal to
#the variable Context_count, defined above. Array indexing starts at 1 (first element is for example something[1])
#Every index refers to the context being configured. As a notation, we use letter "i" for a certain index.
#
#Context arrays must be defined as follows:
#
#Context_Description[i]=(TEXT)
#	-> Free text description that appears on the stdout when context executes
#
#Context_Dates[i]=(TEXT)
#	-> Comma separated numbers, every one is a day that this context can be executed. 
# -> (Don`t forget to include a 29 if it is needed to process by the end of February, due to leap years)
#
#Context_OutputPath[i]=(TEXT)
#	-> Full path to where the script will create a directory (named with the Context_Description underscore process date)
# where the outputs will be placed. If the directory exists, it will create another one with the same name plus 
# underscore and increasing integer.
#
#Context_OutputPostAppendTextToFilename[i]=(TEXT)
#	-> Text to append to the feedback file names after they are generated by the processes
#
#Context_ProcessID[i]=(NUMERIC)
#	-> Process Identification for current process 
#
#Context_InputID[i]=(NUMERIC)
#	-> Input Identification for current process 
#
#Context_InputFile[i]=(TEXT)
#	-> Filename of the extract (input) file
#
#Context_InputPath[i]=(TEXT)
#	-> Path to look for the extract (input) file
#
#Context_SplitOption[i]=(NUMERIC)
#	-> Configures the behavior of the splitting of the extract (input) file.
#	0= No split
# 1= Split the extract according to the number of lines (line feed terminated rows)
# Other integer= Split the extract using this value as the number of characters of ONE record (for plain files)
#
#Context_InputFileAppendExtension[i]=(TEXT)
#	-> Extension to append to the extract file name after this process is completed. Empty string if not required.
#
#Context_PreExecuteScript[i]=(TEXT)
#	-> Full name to an optional script that might be run before starting the execution of current context. Empty
#		 string if not required
#
#Context_PostExecuteScript[i]=(TEXT)
#	-> Full name to an optional script that might be run after starting the execution of current context. Empty 
#		 string if not required
#
##########################################  End of context declaration ############################################

TEXT_PROCESS_NAMED="El proceso llamado:"			
TEXT_PROCESS_SKIPPED="se salteó, no se encontró su extract"
TEXT_PROCESS_FINISHED="terminó"
TEXT_RUN_PRE_EXEC_SCRIPT="Ejecutando el script pre-ejecución:"
TEXT_RUN_POST_EXEC_SCRIPT="Termino el script pre-ejecución:"
TEXT_STARTING_NOW="está empezando..."
TEXT_PROCESS_SYNCRONIZING="Sincronizando procesos..."
TEXT_PROCESS_SYNCRONIZED="Procesos sincronizados!"
###################################################################################################################
############################################### End of help #######################################################
###################################################################################################################


# Verify whether the parameter exists

if [ $# -ne 1 ] ; then
	if [ ! -f "$DateFile" ] ; then
	
		echo Error: No command-line parameter nor execution date file were found
		echo Aborting execution
		exit 1
	fi
	DATE_TO_PROCESS=$(awk -F\, '{print $1}' $DateFile)
else
	DATE_TO_PROCESS=$1
fi

year_process=`expr substr	$DATE_TO_PROCESS 5 4`
month_process=`expr substr 	$DATE_TO_PROCESS 3 2`
day_process=`expr substr 	$DATE_TO_PROCESS 1 2`			

PROCESS_DATE=${year_process}${month_process}${day_process}

###################################################################################################################
######################################### Start of configuration area #############################################
###################################################################################################################

SYS_NAME="ADRetail"

export TRACE=0
export THREAD=4
export Parallel_count=4
export dir_results="/probesm/System1/output/results"

Context_count=12

Context_Description[1]="Fecha de Facturación - Cuentas de DIN con movimiento"
Context_OutputPath[1]="/probesm/System1/output/results"
Context_InsertSM[1]=0
Context_OutputPostAppendTextToFilename[1]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[1]=9
Context_InputID[1]=3
Context_InputFile[1]="PROFACT_1_${PROCESS_DATE}.dat"
Context_InputPath[1]="/probesm/System1/Input"
Context_InputPostAppendTextToFilename[1]=".processed"
#Context_InputPostAppendTextToFilename[1]=""
Context_SplitOption[1]=1
Context_dates[1]="01,05,10,15,20,25"
Context_PreExecuteScript[1]=""
Context_PostExecuteScript[1]=""

Context_Description[2]="Fecha de Facturación - Cuentas de DIN sin movimiento"
Context_OutputPath[2]="/probesm/System1/output/results"
Context_InsertSM[2]=1
Context_OutputPostAppendTextToFilename[2]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[2]=9
Context_InputID[2]=3
Context_InputFile[2]="PROFACTSM_1_${PROCESS_DATE}.dat"
Context_InputPath[2]="/probesm/System1/Input"
Context_InputPostAppendTextToFilename[2]=".processed"
Context_SplitOption[2]=1
Context_dates[2]="01,05,10,15,20,25"
Context_PreExecuteScript[2]=""
Context_PostExecuteScript[2]=""

Context_Description[3]="Fecha de Facturación - Cuentas de ABC con movimiento"
Context_OutputPath[3]="/probesm/System1/output/results"
Context_InsertSM[3]=0
Context_OutputPostAppendTextToFilename[3]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[3]=13
Context_InputID[3]=6
Context_InputFile[3]="PROFACT_22_${PROCESS_DATE}.dat"
Context_InputPath[3]="/probesm/System1/Input"
Context_InputPostAppendTextToFilename[3]=".processed"
Context_SplitOption[3]=1
Context_dates[3]="01,05,10,15,20,25"
Context_PreExecuteScript[3]="dd.ksh"
Context_PostExecuteScript[3]=""

Context_Description[4]="Fecha de Facturación - Cuentas de ABC sin movimiento"
Context_OutputPath[4]="/probesm/System1/output/results"
Context_InsertSM[4]=1
Context_OutputPostAppendTextToFilename[4]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[4]=13
Context_InputID[4]=6
Context_InputFile[4]="PROFACTSM_22_${PROCESS_DATE}.dat"
Context_InputPath[4]="/probesm/System1/Input"
Context_InputPostAppendTextToFilename[4]=".processed"
Context_SplitOption[4]=1
Context_dates[4]="01,05,10,15,20,25"
Context_PreExecuteScript[4]=""
Context_PostExecuteScript[4]=""

Context_Description[5]="Fecha de Facturación - Clientes de DIN con movimiento"
Context_InsertSM[5]=0
Context_OutputPath[5]="/probesm/System1/output/results"
Context_OutputPostAppendTextToFilename[5]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[5]=4
Context_InputID[5]=11
Context_InputFile[5]="Feedback_Cliente_DIN_${DATE_TO_PROCESS}.txt"
Context_InputPath[5]="/probesm/System1/output/results"
Context_InputPostAppendTextToFilename[5]=".processed"
Context_SplitOption[5]=15
Context_dates[5]="01,05,10,15,20,25"
Context_PreExecuteScript[5]=""
Context_PostExecuteScript[5]=""

Context_Description[6]="Fecha de Facturación - Clientes de DIN sin movimiento"
Context_OutputPath[6]="/probesm/System1/output/results"
Context_InsertSM[6]=1
Context_OutputPostAppendTextToFilename[6]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[6]=4
Context_InputID[6]=11
Context_InputFile[6]="Feedback_Cliente_SM_DIN_${DATE_TO_PROCESS}.txt"
Context_InputPath[6]="/probesm/System1/output/results"
Context_InputPostAppendTextToFilename[6]=".processed"
Context_SplitOption[6]=15
Context_dates[6]="01,05,10,15,20,25"
Context_PreExecuteScript[6]=""
Context_PostExecuteScript[6]=""

Context_Description[7]="Fecha de Facturación - Clientes de ABC con movimiento"
Context_OutputPath[7]="/probesm/System1/output/results"
Context_InsertSM[7]=0
Context_OutputPostAppendTextToFilename[7]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[7]=4
Context_InputID[7]=11
Context_InputFile[7]="Feedback_Cliente_ABC_${DATE_TO_PROCESS}.txt"
Context_InputPath[7]="/probesm/System1/output/results"
Context_InputPostAppendTextToFilename[7]=".processed"
Context_SplitOption[7]=15
Context_dates[7]="01,05,10,15,20,25"
Context_PreExecuteScript[7]=""
Context_PostExecuteScript[7]=""

Context_Description[8]="Fecha de Facturación - Clientes de ABC sin movimiento"
Context_OutputPath[8]="/probesm/System1/output/results"
Context_InsertSM[8]=1
Context_OutputPostAppendTextToFilename[8]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[8]=4
Context_InputID[8]=11
Context_InputFile[8]="Feedback_Cliente_SM_ABC_${DATE_TO_PROCESS}.txt"
Context_InputPath[8]="/probesm/System1/output/results"
Context_InputPostAppendTextToFilename[8]=".processed"
Context_SplitOption[8]=15
Context_dates[8]="01,05,10,15,20,25"
Context_PreExecuteScript[8]=""
Context_PostExecuteScript[8]=""

Context_Description[9]="Fin de mes - Cuentas de DIN"
Context_OutputPath[9]="/probesm/System1/output/results"
Context_InsertSM[9]=0
Context_OutputPostAppendTextToFilename[9]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[9]=12
Context_InputID[9]=5
Context_InputFile[9]="PROMENS_1_${PROCESS_DATE}.dat"
Context_InputPath[9]="/probesm/System1/Input"
Context_InputPostAppendTextToFilename[9]=""
Context_SplitOption[9]=1
Context_dates[9]="28,29,30,31"
Context_PreExecuteScript[9]=""
Context_PostExecuteScript[9]=""

Context_Description[10]="Fin de mes - Cuentas de ABC"
Context_OutputPath[10]="/probesm/System1/output/results"
Context_InsertSM[10]=0
Context_OutputPostAppendTextToFilename[10]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[10]=16
Context_InputID[10]=8
Context_InputFile[10]="PROMENS_22_${PROCESS_DATE}.dat"
Context_InputPath[10]="/probesm/System1/Input"
Context_InputPostAppendTextToFilename[10]=""
Context_SplitOption[10]=1
Context_dates[10]="28,29,30,31"
Context_PreExecuteScript[10]=""
Context_PostExecuteScript[10]=""

Context_Description[11]="Fin de mes - Clientes de DIN"
Context_OutputPath[11]="/probesm/System1/output/results"
Context_InsertSM[11]=0
Context_OutputPostAppendTextToFilename[11]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[11]=8
Context_InputID[11]=11
Context_InputFile[11]="Feedback_Cliente_DIN_${DATE_TO_PROCESS}.txt"
Context_InputPath[11]="/probesm/System1/output/results"
Context_InputPostAppendTextToFilename[11]=""
Context_SplitOption[11]=15
Context_dates[11]="28,29,30,31"
Context_PreExecuteScript[11]=""
Context_PostExecuteScript[11]=""

Context_Description[12]="Fin de mes - Clientes de ABC"
Context_OutputPath[12]="/probesm/System1/output/results"
Context_InsertSM[12]=0
Context_OutputPostAppendTextToFilename[12]="_${DATE_TO_PROCESS}.txt"
Context_ProcessID[12]=8
Context_InputID[12]=11
Context_InputFile[12]="Feedback_Cliente_ABC_${DATE_TO_PROCESS}.txt"
Context_InputPath[12]="/probesm/System1/output/results"
Context_InputPostAppendTextToFilename[12]=""
Context_SplitOption[12]=15
Context_dates[12]="28,29,30,31"
Context_PreExecuteScript[12]=""
Context_PostExecuteScript[12]=""

export Business_Area_amount=1

Business_Area[1]="DIN-ABC"

export DateFile="fecha.dat"

DIR_SYSTEM_GEN="/probesm/System"

export ODBCINI=/probesm/odbc32v51/odbc.ini
export PROBESM_CONF_FILE=/probesm/Software/psm.conf.xml

#export SPINLOOPTIME=650
#export MALLOCMULTIHEAP=5
#export AIXTHREAD_MUTEX_DEBUG=OFF
#export AIXTHREAD_SCOPE=S
#export MALLOCTYPE=buckets
export AIXTHREAD_SCOPE=S
export AIXTHREAD_COND_DEBUG=OFF
export AIXTHREAD_MUTEX_DEBUG=OFF
export AIXTREAD_RWLOCK_DEBUG=OFF
export LDR_CNTRL=MAXDATA=0x80000000@DSA
#export SPINLOOPTIME=1000
export YIELDLOOPTIME=8
export MALLOMULTIHEAP=considersize,heaps:8
export MALLOCTYPE=buckets
#export RDBM_CACHE_SIZE=128000
export LANG=en_US
PROC="/probesm/Software/stprocSP1HFC"

###################################################################################################################
######################################### End of configuration area ###############################################
###################################################################################################################


NULL="/dev/null"


CLIENT=${SYS_NAME}".tgt"
INPUT_DIR="${DIR_SYSTEM_GEN}1/Input"

DSN="DSN=PROBESM;UID=PROBESM;PWD=PROBESM"

TEST_TYPE="Standard"

DeleteFlags()
{
	#Delete old flags, from an interrupted sesion
	cd "${DIR_SYSTEM_GEN}1/scripts"
	syst=`expr 1`
	while [[ $syst -le $Parallel_count ]] 
	do
		if [ -f "flag_end_${syst}" ] ; then
			rm "flag_end_${syst}"   	
		fi
		(( syst += 1 ))
	done
}

Verify_parameter()
{
  Count_character=`echo $DATE_TO_PROCESS | wc -c` 
  if [ $Count_character -ne 9 ] ; then
		echo "Bad date, aborting"
		exit 1
  fi

  case $month_process in      
  "01")
  	max_day=31;;
  "02")
		max_day=29;;
  "03")
		max_day=31;;
  "04")
		max_day=30;;    
  "05")
		max_day=31;;
  "06")
		max_day=30;;          
  "07")
		max_day=31;;
  "08")
		max_day=31;;
  "09")
		max_day=30;;          
  "10")
		max_day=31;;
  "11")
		max_day=30;;          
  "12")
		max_day=31;;
	*)
		echo "Bad date, aborting"
		exit 1;;
  esac

	if [[ day_process -gt max_day ]] ; then
		echo "Bad date, aborting"
		exit 1
	fi

	if [[ year_process -lt 2007 ]] ; then
		echo "Bad date, aborting"
		exit 1
	fi
}

Process()
{
	ThisProcess=`expr $1 - 1`  
  PROCESS_DATE=$2
  PROCESS_ID=$3
  INPUT_FILE_NAME=$4
  INPUTDEF_ID=$5

  # call to the ProbeSM procesor
 	$PROC "${DIR_SYSTEM_GEN}$1/$CLIENT" $PROCESS_DATE $PROCESS_ID $DSN "${INPUT_FILE_NAME}" $INPUTDEF_ID $THREAD $TRACE 0 $ThisProcess $Parallel_count

	if [ ${Context_SplitOption[${current_context}]} -ne 0 ] ; then
		#flag the process, used to syncronize
		touch flag_end_$1
	fi
}

MoveDumpLogAndTrace()
{
	#Appends the log and dump from all the systms > 2 to the corresponding parts in ./System
	
	j=`expr 1`
	while [[ $j -le ${Context_count} ]] 
	do
		i=`expr 2`
		while [[ $i -le ${Parallel_count} ]] 
		do
		
			if [ -f "${DIR_SYSTEM_GEN}${i}/log/log${j}.txt" ] ; then
				cat 	"${DIR_SYSTEM_GEN}${i}/log/log${j}.txt" 	>> "${DIR_SYSTEM_GEN}1/log/log${j}.txt"
				rm 		"${DIR_SYSTEM_GEN}${i}/log/log${j}.txt"
			fi

			if [ -f "${DIR_SYSTEM_GEN}${i}/log/dump${j}.txt" ] ; then
				cat 	"${DIR_SYSTEM_GEN}${i}/log/dump${j}.txt" 	>> "${DIR_SYSTEM_GEN}1/log/dump${j}.txt"
				rm 		"${DIR_SYSTEM_GEN}${i}/log/dump${j}.txt"	
			fi
			
			if [[ $TRACE -gt 0 ]] ; then
				if [ -f "${DIR_SYSTEM_GEN}${i}/log/trace${j}.txt" ] ; then
					cat 	"${DIR_SYSTEM_GEN}${i}/log/trace${j}.txt" 	>> "${DIR_SYSTEM_GEN}1/log/trace${j}.txt"
					rm 		"${DIR_SYSTEM_GEN}${i}/log/trace${j}.txt"			
				fi
			fi	
			(( i += 1 ))
		done    
		(( j += 1 ))
	done    		
  
  j=`expr 2`
	while [[ $j -le ${Context_count} ]] 
	do
		if [ -f "${DIR_SYSTEM_GEN}1/log/log${j}.txt" ] ; then
			cat 	"${DIR_SYSTEM_GEN}1/log/log${j}.txt" 	>> "${DIR_SYSTEM_GEN}1/log/log1.txt"
			rm 		"${DIR_SYSTEM_GEN}1/log/log${j}.txt"
		fi
		if [ -f "${DIR_SYSTEM_GEN}1/log/dump${j}.txt" ] ; then
		
			cat 	"${DIR_SYSTEM_GEN}1/log/dump${j}.txt" 	>> "${DIR_SYSTEM_GEN}1/log/dump1.txt"
			rm 		"${DIR_SYSTEM_GEN}1/log/dump${j}.txt"	
		fi
		if [[ $TRACE -gt 0 ]] ; then
			if [ -f "${DIR_SYSTEM_GEN}1/log/trace${j}.txt" ] ; then
				cat 	"${DIR_SYSTEM_GEN}1/log/trace${j}.txt" 	>> "${DIR_SYSTEM_GEN}1/log/trace1.txt"
				rm 		"${DIR_SYSTEM_GEN}1/log/trace${j}.txt"			
			fi	
		fi
		(( j += 1 ))
	done    		
  	
	DT=`date +%d%m%Y-%H%M%S`  	
	if [ -f "${DIR_SYSTEM_GEN}1/log/log1.txt" ] ; then
		mv	"${DIR_SYSTEM_GEN}1/log/log1.txt" "${DIR_SYSTEM_GEN}1/log/Save/log_${DT}_${PROCESS_DATE}.txt"
	fi
	if [ -f "${DIR_SYSTEM_GEN}1/log/dump1.txt" ] ; then
		mv	"${DIR_SYSTEM_GEN}1/log/dump1.txt" "${DIR_SYSTEM_GEN}1/log/Save/dump_${DT}_${PROCESS_DATE}.txt"
	fi
	if [[ $TRACE -gt 0 ]] ; then
		if [ -f "${DIR_SYSTEM_GEN}1/log/trace1.txt" ] ; then
			mv	"${DIR_SYSTEM_GEN}1/log/trace1.txt" "${DIR_SYSTEM_GEN}1/log/Save/trace_${DT}_${PROCESS_DATE}.txt"
		fi
	fi
}

MergeAndSaveResults()
{
	syst=`expr 1`
	dir_dest="${DIR_SYSTEM_GEN}1/output/${Context_InputFile[$current_context]}.out1"
	while [[ $syst -le ${Parallel_count} ]] 
		do
		dir_ori="${DIR_SYSTEM_GEN}${syst}"/output/"${Context_InputFile[${current_context}]}.out${syst}"

		for i in $( ls "$dir_ori" ) ; do		
			file_ori=${i}

			#for those with Context_InsertSM set insert text "SM" (sin movimientos)
			if [ ${Context_InsertSM[${current_context}]} -eq 1 ] ; then
				export ORI=${file_ori}
				file_dest=$(awk 'BEGIN {
					str=ENVIRON["ORI"]
					n=split(str,words,"_")
					for(j=1;j<n;j++) printf("%s_", words[j])
                			printf("SM_%s",words[n])
				}')
			else	
				#file name remains untouched
				file_dest="${i}"
			fi
			file_dest="${file_dest}${Context_OutputPostAppendTextToFilename[${current_context}]}"

#			if [ $syst -eq 1 ] ;
#			then
#				mv "$dir_ori/${file_ori}" "${Context_OutputPath[${current_context}]}/${file_dest}"
				
#			else
				cat "$dir_ori/${file_ori}" >> "${Context_OutputPath[${current_context}]}/${file_dest}"
				rm	"$dir_ori/${file_ori}"
#			fi
		done
		
		#delete the directories created by the processes
		rmdir $dir_ori
		(( syst += 1 ))
	done
}

SaveResultsSingleProcess()
{
	dire="${DIR_SYSTEM_GEN}1/output/${Context_InputFile[$current_context]}"
	for i in $( ls "$dire" ) ; do		
		file_ori=${i}

		#for those with Context_InsertSM set insert text "SM" (sin movimientos)
		if [ ${Context_InsertSM[${current_context}]} -eq 1 ] ; then
			export ORI=${file_ori}
			file_dest=$(awk 'BEGIN {
				str=ENVIRON["ORI"]
				split(str,words,"_")
				for(j=1;j<n;j++) printf("%s_", words[j])
                		printf("SM_%s",words[n])
			}')
		else	
			#file name remains untouched
			file_dest="${i}"
		fi
		file_dest="${file_dest}${Context_OutputPostAppendTextToFilename[${current_context}]}"
		mv "$dire/${file_ori}" "${Context_OutputPath[${current_context}]}/${file_dest}"

	done
	rmdir $dire
}

DeleteFragments ()
{
	this_file="${Context_InputFile[${current_context}]}"
	this_dir="${Context_InputPath[${current_context}]}"
	syst=`expr 1`
	while [[ $syst -le ${Parallel_count} ]] 
	do
		echo "${this_dir}/${this_file}.out${syst}"
		if [ -f "${this_dir}/${this_file}.out${syst}" ] ;
		then
			rm "${this_dir}/${this_file}.out${syst}"
		fi
		(( syst += 1 ))		
	done
}

Split ()
{
	DeleteFragments
	#delete any temporal, old chunk
	rm -f "xa*"

	syst=`expr 1`
	while [[ $syst -le ${Parallel_count} ]] 
	do
		if [ -f "${1}/${2}.out${syst}" ] ;
		then
			rm "${1}/${2}.out${syst}"
		fi
		(( syst += 1 ))		
	done
	echo
	echo "Splitting the extract ${2} into $Parallel_count parts..."		    	

	cd "${1}"
  
  if [ ${Context_SplitOption[${current_context}]} -ne 1 ] ; then
	  file_size=`wc -c < $2`
	  fragment_size=`expr $file_size / ${Context_SplitOption[${current_context}]} / $Parallel_count `
	  fragment_size=`expr $fragment_size \* ${Context_SplitOption[${current_context}]} `
	  split -b $fragment_size "${2}"
  else
	  nb_lines=`wc -l < $2`
	  lineas_split=`expr $nb_lines / $Parallel_count`
	  split -l $lineas_split "${2}"
  fi
  
	#Calculate how many files were actually created
	syst=`expr 0`
	for i in $( ls "${1}/" | grep xa ); do		
		(( syst += 1 ))
	done	
	
	alphabet="abcdefghijklmnopqrstuvwxyz"

	if [[ $syst > $Parallel_count ]] ; then
		letter_from=`expr substr	$alphabet $syst 1`
		letter_to=`expr substr	$alphabet $Parallel_count 1`
		cat "xa${letter_from}" >> "xa${letter_to}"
		rm "xa${letter_from}"
	fi

	syst=`expr 1`
	for i in $( ls "${1}/" | grep xa ); do		
		mv  "${1}/$i" "${1}/${2}.out${syst}"
  	if [ ${Context_SplitOption[${current_context}]} -ne 1 ] ; then
 			result_count=`wc -c < "${2}.out${syst}"`
 			result_count=`expr ${result_count}`
 			result_count=`expr ${result_count} / ${Context_SplitOption[${current_context}]}`
		 	echo "${2}.out${syst} => $result_count records"
	else
 			result_count=`wc -l < "${2}.out${syst}"`
		 	echo "${2}.out${syst} => $result_count lines"
		fi
		(( syst += 1 ))		
	done	
	
	echo "End of split"		    	

}

Synchronize()
{
		
	echo $TEXT_PROCESS_SYNCRONIZING
	syst=`expr 0`
	while [[  $syst < $Parallel_count ]] 
	do
		syst=`expr 0`
		for i in $( ls "${DIR_SYSTEM_GEN}1/scripts/" | grep flag_end_ ); do
			(( syst += 1 ))		
		done	
		sleep 5
	done
	
	#Remove the flags					
	DeleteFlags
	sleep 5
	echo $TEXT_PROCESS_SYNCRONIZED
	echo
}

SaveTempDumpLogAndTrace()
{
	syst=`expr 1`
	while [[ $syst -le $Parallel_count ]] 
	do
		#echo "Renaming dump for System${syst}"
		ls ${DIR_SYSTEM_GEN}${syst}/log/dump_*.txt 2>/dev/null | while read file
	  do
	  	echo "${Context_Description[${current_context}]}, instance ${syst} starts below" > ${DIR_SYSTEM_GEN}${syst}/log/dump${current_context}.txt
	    cat $file >> ${DIR_SYSTEM_GEN}${syst}/log/dump${current_context}.txt
	  	rm $file
	  done 2>>error
		echo >> ${DIR_SYSTEM_GEN}${syst}/log/dump${current_context}.txt
		echo -------------------------------------------------------------- >> ${DIR_SYSTEM_GEN}${syst}/log/dump${current_context}.txt
	
		#echo "Renaming Log for System${syst}"

	  echo "${Context_Description[${current_context}]}, instance ${syst} starts below" > ${DIR_SYSTEM_GEN}${syst}/log/log${current_context}.txt	
		cat "${DIR_SYSTEM_GEN}${syst}/log/log.txt" >> ${DIR_SYSTEM_GEN}${syst}/log/log${current_context}.txt
		rm  "${DIR_SYSTEM_GEN}${syst}/log/log.txt"
		#cat	${DIR_SYSTEM_GEN}1/scripts/separador.txt >> ${DIR_SYSTEM_GEN}${syst}/log/log${current_context}.txt
		echo >> ${DIR_SYSTEM_GEN}${syst}/log/log${current_context}.txt
		echo -------------------------------------------------------------- >> ${DIR_SYSTEM_GEN}${syst}/log/log${current_context}.txt
		
		if [[ $TRACE -gt 0 ]] ; then
			#echo "Renaming Trace for System${syst}"
			ls ${DIR_SYSTEM_GEN}${syst}/log/trace_*.txt* 2>/dev/null | while read file
		  do
	  		echo "${Context_Description[${current_context}]}, instance ${syst} starts below" > ${DIR_SYSTEM_GEN}${syst}/log/trace${current_context}.txt	
		    cat $file >> ${DIR_SYSTEM_GEN}${syst}/log/trace${current_context}.txt
		 		rm "$file"
		  done 2>>error
			#cat	${DIR_SYSTEM_GEN}1/scripts/separador.txt >> ${DIR_SYSTEM_GEN}${syst}/log/trace${current_context}.txt	  
			echo >> ${DIR_SYSTEM_GEN}${syst}/log/trace${current_context}.txt	  
			echo -------------------------------------------------------------- >> ${DIR_SYSTEM_GEN}${syst}/log/trace${current_context}.txt	  
		fi
		
		rm ${DIR_SYSTEM_GEN}${syst}/log/*.dat
		(( syst += 1 ))
	done
}

#**********************************************************************************************************
#*********************************************** Main program **********************************************
#**********************************************************************************************************


Verify_parameter

start_time=`date +%d/%m/%Y-%H:%M:%S`
start_time_unix=`date +%s`
records_total=`expr 0`
echo "Start time: $start_time"


# Update systems (tgt, cdf)
syst=`expr 2`
while [[ $syst -le $Parallel_count ]] 
do
	cp "${DIR_SYSTEM_GEN}1/${SYS_NAME}.tgt" "${DIR_SYSTEM_GEN}${syst}/"
	cp "${DIR_SYSTEM_GEN}1/${SYS_NAME}.cdf" "${DIR_SYSTEM_GEN}${syst}/"
	(( syst += 1 ))
done

syst=`expr 2`
while [[ $syst -le $Parallel_count ]];do 
	if [[ ! -d "${DIR_SYSTEM_GEN}${syst}" ]] ; then
# Crea directorios de cada sistema
		mkdir "${DIR_SYSTEM_GEN}${syst}"
	fi	
	if [[ ! -d "${DIR_SYSTEM_GEN}${syst}/output" ]] ; then
# Create output directory 
		mkdir "${DIR_SYSTEM_GEN}${syst}/output"
	fi	
# Create log directory 
	if [[ ! -d "${DIR_SYSTEM_GEN}${syst}/log" ]] ; then
		mkdir "${DIR_SYSTEM_GEN}${syst}/log"
	fi	
# Create Business Area directory
	if [[ ! -d "${DIR_SYSTEM_GEN}${syst}/Business Area/" ]] ; then
		mkdir "${DIR_SYSTEM_GEN}${syst}/Business Area/"
	fi	
	(( syst += 1 ))
done

syst=`expr 1`
while [[ $syst -le $Parallel_count ]];do 
	cd "${DIR_SYSTEM_GEN}${syst}/output"
# Delete old outputs from an interrupt sesion
	if [ -f * ] ; then
		rm *
	fi
	cd "${DIR_SYSTEM_GEN}${syst}/log"
# Delete old logs from an interrupt sesion
	if [ -f * ] ; then
		rm *
	fi
	(( syst += 1 ))
done

cd "${dir_results}"
for i in $( ls "${dir_results}" | grep $PROCESS_DATE | grep -v .old ) ; do		
	mv "${i}" "${i}.old"
done

# Creates business areas directories and copies the strategies
syst=`expr 2`
while [[ $syst -le $Parallel_count ]];do 
	b_a=`expr 1`	
	while [[ $b_a -le $Business_Area_amount ]];do 
		if [[ ! -d "${DIR_SYSTEM_GEN}${syst}/Business Area/${Business_Area[${b_a}]}/" ]] ; then
			mkdir "${DIR_SYSTEM_GEN}${syst}/Business Area/${Business_Area[${b_a}]}/"
		else
			cd "${DIR_SYSTEM_GEN}${syst}/Business Area/${Business_Area[${b_a}]}/"
			if [ -f * ] ; then
				rm *
			fi
		fi	
		cp -r "${DIR_SYSTEM_GEN}1/Business Area/${Business_Area[${b_a}]}/" "${DIR_SYSTEM_GEN}${syst}/Business Area/"
		(( b_a += 1 ))
	done
	(( syst += 1 ))
done

current_context=`expr 1`


while [[ $current_context -le $Context_count ]] 
do

	cd "${DIR_SYSTEM_GEN}1/scripts"
	echo ${Context_dates[${current_context}]} > date_list.tmp
	
	#only run this process if the date applies

	if grep ${day_process} date_list.tmp > /dev/null 2>&1 ; then

		export extract_file="${Context_InputFile[${current_context}]}"

		if [ -f "${Context_InputPath[${current_context}]}/${extract_file}" ] ; then
			echo
			echo --------------------------------------------------------------
			echo $TEXT_PROCESS_NAMED
			echo "${Context_Description[${current_context}]}"
			echo $TEXT_STARTING_NOW
			echo --------------------------------------------------------------

			DeleteFlags

			#if no parallel processing, force no spliting
		  if [ ${Parallel_count} -eq 1 ] ; then
				Context_SplitOption[${current_context}]=0
			fi
			
			if [ ${Context_PreExecuteScript[${current_context}]} ] ; then
				echo
				echo "$TEXT_RUN_PRE_EXEC_SCRIPT ${Context_PreExecuteScript[${current_context}]}"
				${Context_PreExecuteScript[${current_context}]}
				echo
				echo "$TEXT_RUN_POST_EXEC_SCRIPT ${Context_PreExecuteScript[${current_context}]}"
			fi

		  if [ ${Context_SplitOption[${current_context}]} -ne 0 ] ; then

				Split "${Context_InputPath[${current_context}]}" "${extract_file}"
				
			fi
	
			sleep 30
			
		  cd "${DIR_SYSTEM_GEN}1/scripts"
		  
			syst=`expr 1`
			
			while [[ $syst -le $Parallel_count ]] 
			do
				#Processes the instances

			  if [ ${Context_SplitOption[${current_context}]} -ne 0 ] ; then
	
					file_to_process="${Context_InputPath[${current_context}]}/${extract_file}.out${syst}"
				
					#process in background
					
					Process $syst $PROCESS_DATE ${Context_ProcessID[${current_context}]} $file_to_process ${Context_InputID[${current_context}]} &
				
				else 

					file_to_process="${Context_InputPath[${current_context}]}/${extract_file}"
					
					#process in foreground
										
					Process $syst $PROCESS_DATE ${Context_ProcessID[${current_context}]} $file_to_process ${Context_InputID[${current_context}]}
				
				fi

				(( syst += 1 ))			

			done
			
			if [ ${Context_SplitOption[${current_context}]} -ne 0 ] ; then

				#Synchronze all the instances
			
				Synchronize		
			
				MergeAndSaveResults
			
			else

				SaveResultsSingleProcess

			fi
									
			SaveTempDumpLogAndTrace		
					
			if [ ${Context_SplitOption[${current_context}]} -ne 0 ] ; then

				DeleteFragments

			fi
			
			#Post-execution renaming of the extract
			if [ ${Context_InputPostAppendTextToFilename[${current_context}]} ] ; then
				mv "${Context_InputPath[${current_context}]}/${extract_file}" "${Context_InputPath[${current_context}]}/${extract_file}${Context_InputPostAppendTextToFilename[${current_context}]}"
			fi

			#Post-execution script				
			if [ ${Context_PostExecuteScript[${current_context}]} ] ; then
				echo "Running post-execute script called: ${Context_PostExecuteScript[${current_context}]}"
				${Context_PostExecuteScript[${current_context}]}
				echo "Finished post-execute script called: ${Context_PostExecuteScript[${current_context}]}"
			fi

			echo			
			echo --------------------------------------------------------------
			echo $TEXT_PROCESS_NAMED
			echo "${Context_Description[${current_context}]}"				
			echo $TEXT_PROCESS_FINISHED
			echo --------------------------------------------------------------

		else
			echo
			echo --------------------------------------------------------------
			
			echo $TEXT_PROCESS_NAMED
			echo "${Context_Description[${current_context}]}"
			echo $TEXT_PROCESS_SKIPPED
			echo --------------------------------------------------------------
		fi

	fi

	(( current_context += 1 ))
	
done

MoveDumpLogAndTrace

end_time=`date +%d/%m/%Y-%H:%M:%S`
end_time_unix=`date +%s`
let exec_time=$end_time_unix-$start_time_unix
echo
echo " Summary"
echo " Start time: $start_time"	
echo " End time: $end_time"
echo " Execution time: $exec_time seconds"
echo
