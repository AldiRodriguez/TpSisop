#!/usr/bin/perl

#NO VA A ANDAR CON EL EJECUTADO DE VERDAD, ARREGLAR REGEXS EN LAS ULTIMAS DOS FUNCS no corregi los regexes
#NO ESTÁ INTEGRADO control AL MENU (se supone que sí pero no lo probé!!)
#ejecutado no cierra los archivos


$ayudaSancionado="	sancionado: muestra el presupuesto sancionado ordenado con subtotales por central(ct) o por trimestre(tc)\n	Uso:\n		 listep sancionado ct|tc <AÑO> [-f archivo de salida]\n";
$ayudaControl="	control: listados de control del presupuesto ejecutado\n	Uso:\n		 listep control [<trimestres>] [centro1 centro2 ...] [-f archivo de salida]\n<trimestres> puede ser una lista de trimestres, por ejemplo 2016-1 2015-4 1998-2 . Omitir para seleccionar todos los trimestres\n<centros>: omitir para mostrar todos los centros, puede escribir una lista de centros (códigos de centro) o un rango de centros, por ejemplo 0.0.0.1-3*\n";
$ayudaAyuda ="	ayuda: ayuda del programa. Uso:\n		listep ayuda <comando>\n";
$ayudaEjecutado="	ejecutado: muestra listados del presupuesto ejecutado, ordenados de manera ct o tc (ver listep ayuda sancionado). Permite filtrar actividades pero por defecto muestra todas.\n	Uso:\n		listep ejecutado ct|tc <AÑO> [actividad1 actividad2 ... ] [-f archivo de salida]\n";

#  El hash comandos es el alma del programa:
#a cada comando le corresponde una función 
#que tiene su nombre. Para que detecte el comando
#hay que agregar el nombre de la función/del coamdno
#al hash abajo, y el value que le corresponde es cómo usar el comando

%comandos=("sancionado" => $ayudaSancionado, "ayuda"=> $ayudaAyuda, "ejecutado" => $ayudaEjecutado, "control" => $ayudaControl);

#Hashes por opción. Explican cada opción, la validan y la almacenan

$ctTcDefault="ct";
%argCtTc=("explicacion" => "Cómo ordenar la salida. ct:ordenar por central y luego por trimestre. tc: lo opuesto",
	"validador"=>"esCtTc",
	"valor"=>\$ctTcDefault,
	"esLista"=>0,
	"nombre"=>"orden",
);

$anioDefault="2016";
%argAnio=("explicacion" => "Año sobre el cual se opera",
	"validador"=>"esAnio",
	"valor"=>\$anioDefault,
	"esLista"=>0,
	"nombre"=>"año",
);

@actividadesDefault=(); #("Desarrollo de Aplicativos");
%argActividades=(
	"explicacion" => "Actividades para filtrar (por nombre). Dejar vacío para no filtrar ninguna.",
	"validador"=>"esActividadCargandoArchivo",
	"valor"=>\@actividadesDefault,
	"esLista"=>1,
	"nombre"=>"actividades",
);

@trimestresDefault=(); #("Desarrollo de Aplicativos");
%argTrimestres=(
	"explicacion" => "Trimestres para filtrar, en formato año-trimestre, como 2015-1 2016-2. Dejar vacío para no filtrar ninguna.",
	"validador"=>"esTrimestre",
	"valor"=>\@trimestresDefault,
	"esLista"=>1,
	"nombre"=>"trimestres",
);

@centrosDefault=(); #("Desarrollo de Aplicativos");
%argCentros=(
	"explicacion" => "Códigos de los centros a filtrar, acepta rangos, por ejemplo 0.0.0.1-3, 0.0.0.1-2* .Dejar vacío para no filtrar ninguna.",
	"validador"=>"esFiltroDeCentro",
	"valor"=>\@centrosDefault,
	"esLista"=>1,
	"nombre"=>"centros",
);


#arrays de argumentos de cada comando, van en el orden de los comandos. apuntan a hashes de cada opción.
@argsSancionado=(\%argCtTc,\%argAnio);
@argsAyuda=();#sin argumentos por default
@argsEjecutado=(\%argCtTc,\%argAnio,\%argActividades);
@argsControl =(\%argTrimestres, \%argCentros);####################################################################



#este hash de argumentos tiene referencias a listas de los argumentos actuales, es utilizado para definir los argumentos default de la aplicación interactiva
%argumentos=("sancionado" => \@argsSancionado, "ayuda"=> \@argsAyuda, "ejecutado" => \@argsEjecutado, "control" => \@argsControl);





$lARGV=@ARGV;
$archivoSalida=STDOUT;
$dirmae=$ENV{GRUPO}."mae";#esto no esta bien
$dirproc=$ENV{GRUPO}."proc";#esto no esta bien

#---------------------------------------------COMUNES - PARSEO------------------------------#
$formaRegistroEjecutado="^([0-9]*);([0-9]*);([0-9.\-]*);([A-Za-z 0-9]*);([A-Za-z 0-9]*);([0-9,]*)\$";
$formaEjecutadoRx=qr/^([0-9]*);([0-9]*);([0-9.\-]*);([A-Za-z 0-9]*);([A-Za-z 0-9]*);([0-9,]*)$/;
sub idEjecutado{
	
	my $arg = shift;
	$arg =~ s/$formaRegistroEjecutado/\1/;
	return $arg;
}
sub fechaEjecutado{
	my $arg = shift;
	$arg =~ s/$formaRegistroEjecutado/\2/;
	return $arg;
}
sub codCentroEjecutado{
	my $arg = shift;
	$arg =~ s/$formaRegistroEjecutado/\3/;
	return $arg;
}
sub actividadEjecutado{
	my $arg = shift;
	$arg =~ s/$formaRegistroEjecutado/\4/;
	return $arg;
}
sub trimestreEjecutado{
	my $arg = shift;
	$arg =~ s/$formaRegistroEjecutado/\5/;
	return $arg;
}
sub dineroEjecutado{
	my $arg = shift;
	$arg =~ s/$formaRegistroEjecutado/\6/;
	my $plata = comaPorPunto($arg);
	return $plata;
}

sub codActividadEjecutado{
	return "codact";#"codigo de actividad aqui";
}
sub provinciaEjecutado{
	return "nomProv";#"Nombre de provincia aqui";
}
#qr/^([0-9.\-]*);([A-Za-z 0-9]*);[0-9,]*;[0-9,]*$/
$formaRegistroSancionado = "^([0-9.\-]*);([A-Z a-z0-9]*);([0-9,]*);([0-9,]*)\$";
$formaSancionadoRx=qr/^([0-9.\-]*);([A-Za-z 0-9]*);([0-9,]*);([0-9,]*)$/;
sub codCentroSancionado{
	my $arg = shift;
	#por algun motivo se corta el primer 0 del registro, esto lo agrega
	#if ( $arg =~/^.0/){
	#	$arg = "0$arg";
	#}
	
	$arg =~ s/$formaRegistroSancionado/\1/;
	return $arg;
}
sub trimestreSancionado{
	my $arg = shift;
	$arg =~ s/$formaRegistroSancionado/\2/;
	return $arg;
}
sub plata1Sancionado{
	my $arg = shift;
	$arg =~ s/$formaRegistroSancionado/\3/;
	my $ret = comaPorPunto($arg);
	return $ret;
}
sub plata2Sancionado{
	my $arg = shift;
	$arg =~ s/$formaRegistroSancionado/\4/;
	my $ret = comaPorPunto($arg);
	return $ret;
}
sub plataTotalSancionado{
	my $arg = shift;
	my $suma = plata1Sancionado($arg) + plata2Sancionado($arg);
	return $suma;
}
sub plataTotalSancionadoComa{
	my $arg = shift;
	my $ret = plataTotalSancionado($arg);
	my $conComa = puntoPorComa($ret);
	return $conComa;
}

#---------------------------------------------COMUNES---------------------------------------#
sub puntoPorComa{
	my $ret=shift;
	$ret =~ s/\./,/;
	return $ret;
}
sub comaPorPunto{
	my $ret=shift;
	$ret =~ s/,/./;
	return $ret;
}
sub trimestreAValor {
	my $fecha = lc(shift);
	#saco el trimestre
	my $trimestre =$fecha;
	$trimestre=~s/.*primer.*/1/;
	$trimestre=~s/.*segundo.*/2/;
	$trimestre=~s/.*tercer.*/3/;
	$trimestre=~s/.*cuarto.*/4/;
	if ($trimestre <= 0 or trimestre >=5){
		$trimestre = 0;
	}
	
	#saco el anio (no hace falta en realidad)
	my $anio = $fecha;
	$anio=~s/.*(\d\d\d\d).*/\1/;
	
	return ( $anio * 10) + $trimestre;
}

sub cmpCentros {
	my $codigoA=shift;
	my $codigoB=shift;
	my $refcentros=shift;

	my %centros =%{$refcentros};

	my $nombreA = $centros{$codigoA};
	my $nombreB = $centros{$codigoB};

	my $comp = $nombreA cmp $nombreB;
	
	return $comp;
}

sub cmpTrimestres {
	my $trimestreA=shift;
	my $trimestreB=shift;
	my $va = trimestreAValor($trimestreA);
	my $vb = trimestreAValor($trimestreB);
	my $comp = $va cmp $vb;
	return $comp;
}
sub indiceOrdenado{
	my $fp = shift;
	my $opcion = shift;
	my $refIndice = shift;
	my $refCentros = shift;
	my $filtrarTrimestre = shift;
	my $filtrarCentro = shift;
	my $comoOrdenarCentros = shift;
	my $cmpTrimestres = shift;
	
	my @registros = @$refIndice;

	#asumo tc
	my $criterio1=sub { 
		my $trimestreA = &{$filtrarTrimestre}(@_[0]);
		my $trimestreB = &{$filtrarTrimestre}(@_[1]);
		my $comp = &{$cmpTrimestres}($trimestreA, $trimestreB);
		#print "$trimestreA $trimestreB $comp\n";
		return $comp
	};
	
	my $criterio2=sub { 
		my $centroA = &{$filtrarCentro}(@_[0]);
		my $centroB = &{$filtrarCentro}(@_[1]);
		if ($comoOrdenarCentros eq "codigo"){
			return ($centroA cmp $centroB);
		}
		my $comp = cmpCentros($centroA, $centroB ,$refCentros);
		return $comp;
	};
	
	if ($opcion eq "ct"){#intercambia criterios si asumí mal
		my $c = $criterio1;
		$criterio1 = $criterio2;
		$criterio2=$c;
	}
	
	#ordenado del índice
	my @ordenados = sort{ 
		my $regA = leerRegistro($a, $fp);
		my $regB = leerRegistro($b, $fp);
		my $comp = &{$criterio1} ($regA, $regB) ;
		if ($comp == 0){
			$comp = &{$criterio2}( ($regA, $regB) );
		}
		return $comp
	} @registros;
	
	return @ordenados;
}
sub leerRegistro {
	my $posicion = shift;
	my $fileHandle = shift;
	seek($fileHandle,$posicion,0);
	my $linea = <$fileHandle>;
	chop($linea);
	return $linea;
}

#esto devuelve un array de las posiciones en bytes de cada línea.
#A leerRegistro se le pasa un elemento de este array y el archivo
#y te devuelve la línea
#la regexp se arma raro!!! notar el qr en el llamado que hice
sub indexarArchivo{
	my $archivo = shift;
	my $regexValidacion = shift;
	
	seek($archivo,0,0);
	
	my @registros=();
	while(my $linea = <$archivo> ){
		if ( $linea =~ $regexValidacion ){
			my $posicion=tell $archivo;
			my $pos_inicio = $posicion - length($linea);
			push(@registros,$pos_inicio); #los archivos no entran en memoria
		}
	}
	
	return @registros;
}

#Transforma un archivo en un hash, (lo carga en memoria!)
sub hashDeArchivo{
	my $nombreArchivo=shift;
	my $patron = shift;
	my $filtroKey = shift;
	my $filtroValue = shift;
	
	open(ARCHIVO,"<$nombreArchivo") or die "No está disponible el archivo: $nombreArchivo";
	
	my %ret =();
	while( my $linea = <ARCHIVO>){
		if( $linea =~ $patron){
			chop($linea);
			my $clave = &{$filtroKey}($linea);
			my $valor = &{$filtroValue}($linea);
			$ret{$clave}=$valor;
		}
	}

	close ARCHIVO;
	return %ret;
}

sub parsearActividades {
	my $nombreActividades = "$dirmae/actividades.csv";
	my $nombreCentros =  "$dirmae/actividades.csv";
	my $pattern =qr/^(.*);([A-Za-z 0-9]*);([A-Za-z 0-9]*);([A-Za-z 0-9]*)$/;
	my $filtroClave = sub {
		my $matame=$_[0];
		$matame=~s/$pattern/$1/;
		return $matame;
	};
	my $filtroValor = sub {
		my $matame=$_[0];
		$matame=~s/$pattern/$4/;
		return $matame;
	};
	return hashDeArchivo($nombreActividades,$pattern,$filtroClave,$filtroValor);
}
sub pasaPorFiltros {
	my $candidato = shift;
	my $regFiltros = shift;
	
	my @filtros=@{$regFiltros};
	
	if ( scalar @filtros == 0){
		return 1;
	}
	
	foreach my $filtro (@filtros){
		if( $candidato eq $filtro){
			return 1;
		}
	}
	
	return 0;
}
sub esActividad {
	my $candidato = shift;
	my $refActividades = shift;

	my %actividades = %{$refActividades};

	foreach $actividad (values(%actividades)){
		if( $candidato eq $actividad ){
			return 1;
		}
	}
	return 0;
}
#---------------------------------------------CONTROL---------------------------------------#
sub esTrimestre{
	my $trimestre = shift;
	
	if ($trimestre !~ /^\d\d\d\d-\d$/){
		return "$trimestre no es un trimestre válido\n";
	}else{
		return "";
	}
}

sub esFiltroDeCentro{
	my $filtro = shift;
	
	if($filtro =~ /[0-9.\-]*/){
		return "";
	}else{
		return "$filtro no es un filtro de centros\n";
	}
}

sub archivosFiltrados{
	my $carpeta = shift;
	my $criterioFiltrado = shift;
	
	if( not opendir(DIR,$carpeta)){
		return "No puedo abrir $carpeta";
	}
	
	my @nombresArchivos = readdir(DIR);
	close(DIR);
	
	my @filtrados =();
	
	for my $archivo (@nombresArchivos){
		
		if ( &{$criterioFiltrado}($archivo) eq "si"){
			push @filtrados, $archivo;
		}
	}
	
	return @filtrados;
}
sub parsearTrimestres{
	my $nombreActividades = "$dirmae/trimestres.csv";
	my $pattern =qr|^\d\d\d\d;([A-Za-z 0-9]*);([/0-9]*);[0-9/]*$|;
	#my $pattern =qr/^(.*);([A-Za-z 0-9]*);([A-Za-z 0-9]*);([A-Za-z 0-9]*)$/;
	my $filtroClave = sub {
		my $matame=$_[0];
		$matame=~s/$pattern/$1/;
		return $matame;
	};
	my $filtroValor = sub {
		my $reg=$_[0];
		$reg=~s/$pattern/$2/;
		my $codFecha = $reg;
		$codFecha =~ s|(\d\d)/(\d\d)/(\d\d\d\d)|\3\2\1|;
		return $codFecha;
	};
	my %hash = hashDeArchivo($nombreActividades,$pattern,$filtroClave,$filtroValor);
	return %hash;
}
sub control{
	#parseo las fechas, después sirven
	my %trimestres = &parsearTrimestres;
	#parseo las actividades, despues sirven
	my %actividades = &parsearActividades;
	#validar cantidad de argumentos
	my $largo =@_;
	
	#validar trimestres
	my @trimestres =();
	my @centrosPosibles=();
	foreach my $elemento (@_){
		if( &esTrimestre($elemento) eq ""){
			push @trimestres, $elemento;
		}else{
			push @centrosPosibles, $elemento;
		}
	}
	
	#validar centros
	my @centros =();
	foreach my $elemento (@centrosPosibles){
		if (&esFiltroDeCentro($elemento) eq ""){
			push @centros, $elemento;
		}else{
			return "$elemento no es trimestre ni filtro de centro\n";
		}
	}
	
	
	#Crear listas de archivos de presupuesto ejecutado y de archivos de sancionado, filtrando por cuatrimestre
	sub stringTieneTrimestre{
		my $nombre = shift;
	
		my $largo = @trimestres;
		if ( ($largo == 0) and ($nombre=~/.*\d\d\d\d.*/)){
			return "si";
		}
		
		foreach my $trimestre (@trimestres){
			my $anio =$trimestre;
			$anio =~ s/^(\d\d\d\d)-\d$/\1/;
			if( $nombre =~ /.*$anio.*/){
				return "si";
			}
		}
		return "no";
	}
	
	my @ejecutadoFiltrados = &archivosFiltrados($dirproc,\&stringTieneTrimestre);
	my @sancionadoFiltrados = &archivosFiltrados($dirmae,\&stringTieneTrimestre);
	
	#abrir y ordenar todos los archivos
	
	#abrir y ordenar ejecutados
	my %centros = &parsearCentros;
	
	sub cmpFechas{
		my $fA=shift;
		my $fB=shift;
		return ($fA cmp $fB);
	}
	
	my @TDAejecutados = ();
	foreach my $nombre (@ejecutadoFiltrados){
		open(my $archivo,"<$dirproc/$nombre") or return "No se pudo abrir el arhivo $dirproc/$nombre";
		my @indice = &indexarArchivo($archivo,$formaEjecutadoRx);
		@ordenado = indiceOrdenado($archivo,"ct",\@indice,\%centros,\&fechaEjecutado, \&codCentroEjecutado,"codigo",\&cmpFechas);
		my $largo = @ordenado;
		if ($largo != 0){
			my @TDAarchivo = ();
			push @TDAarchivo, 0;#el primero es el iterador
			push @TDAarchivo, $archivo;#el segundo es el file pointer
			push @TDAarchivo, @ordenado;#el tercero es el resto, el indice ordenado.
			push @TDAejecutados, \@TDAarchivo;
		}
	}
	#abrir y ordenar sancionados
	my @TDAsancionados =();
	foreach my $nombre (@sancionadoFiltrados){
		open(my $archivo,"<$dirmae/$nombre") or return "No se pudo abrir el arhivo $dirmae/$nombre";
		my @indice = &indexarArchivo($archivo,$formaSancionadoRx);
		@ordenado = indiceOrdenado($archivo,"ct",\@indice,\%centros,\&trimestreSancionado, \&codCentroSancionado,"codigo",\&cmpTrimestres);
		
		my $largo = @ordenado;
		if ($largo != 0){
			my @TDAarchivo = ();
			push @TDAarchivo, 0;#el primero es el iterador
			push @TDAarchivo, $archivo;#el segundo es el file pointer
			push @TDAarchivo, @ordenado;#el tercero es el resto, el indice ordenado.
			push @TDAsancionados, \@TDAarchivo;
		}
	}
	
	#definir los filtros de los registros interesantes o no interesantes
	sub filtrarPorTrimestre{
		
		my $cantidadFiltros = @trimestres;
		if ($cantidadFiltros == 0){
			return "pasa";
		}
		
		my $trimestreTexto = shift;
		#print "analizo $trimestreTexto\n";
		my $nroTrimestre = 0;
		
		if ( $trimestreTexto =~ /.*[Pp]rimer.*/){
			$nroTrimestre = 1;
		}
		if ( $trimestreTexto =~ /.*[Ss]egundo.*/){
			$nroTrimestre = 2;
		}
		if ( $trimestreTexto =~ /.*[Tt]ercer.*/){
			$nroTrimestre = 3;
		}
		if ( $trimestreTexto =~ /.*[Cc]uarto.*/){
			$nroTrimestre = 4;
		}
		
		my $anio = $trimestreTexto;
		$anio =~ s/.*(\d\d\d\d).*/\1/;
		
		my $codigoTrimestre = "$anio-$nroTrimestre";
		foreach my $trimestre (@trimestres){
			if ($trimestre eq $codigoTrimestre){
				#print "Pasa un $trimestreTexto\n";
				return "pasa";
			}
		}
		#print "Salteo un $trimestreTexto\n";
		return "saltear";
	}
	sub filtrarPorCentro{
		my $aFiltrar = shift;

		my $cantidadFiltros = @centros;
		if($cantidadFiltros==0){
			return "pasa";
		}
		
		foreach my $centro (@centros){
			#transformar $centro en una regex
			my $regexCentro = $centro;
			$regexCentro =~s/\./\\\./g;#reemplazar . por \.
			$regexCentro =~s/\*/\.\*/g;#reemplazar * por .*
			$regexCentro ="^$regexCentro\$";
			if( $aFiltrar =~ /$regexCentro/ ){
				return "pasa";
			}
		}
		return "saltear";
	}
	
	sub filtroSancionados{
		my $aFiltrar = shift;
		
		my $trimestre = &trimestreSancionado($aFiltrar);
		my $pasaTrimestre = &filtrarPorTrimestre($trimestre);
		my $centro = &codCentroSancionado($aFiltrar);
		my $pasaCentros = &filtrarPorCentro($centro);
		if( ($pasaTrimestre eq "pasa") and ($pasaCentros eq "pasa") ){
			return "pasa";
		}else{
			return "saltear";
		}
	}
	sub filtroEjecutados{
		my $aFiltrar = shift;
		
		my $pasaTrimestre = &filtrarPorTrimestre(&trimestreEjecutado($aFiltrar));
		my $pasaCentros = &filtrarPorCentro(&codCentroEjecutado($aFiltrar));
		if( ($pasaTrimestre eq "pasa") and ($pasaCentros eq "pasa") ){
			return "pasa";
		}else{
			return "saltear";
		}
	}
	
	#mergear archivos
	print $archivoSalida "ID;FECHA_MOV;CENTRO;ACTIVIDAD;TRIMESTRE;IMPORTE;SALDO_POR_TRIMESTRE;CONTROL;SALDO_ACUMULADO\n";
	while( 
		(&archivosTerminados(\@TDAsancionados) eq "no") 
		#or
		#(&archivosTerminados(\@TDAejecutados) eq "no") 
	){
		my $saldo_total = 0;
		my $saldo_trimestral = 0;
		
		#avanzar todos los archivos hasta el proximo registro no-filtrado
		&avanzarIteradoresFiltrando(\@TDAsancionados,\&filtroSancionados);
		&avanzarIteradoresFiltrando(\@TDAejecutados,\&filtroEjecutados);
	
		#tomo el primer centro, hago todo para ese centro
		my $primerRegistro = &obtenerPrimerCentro(\@TDAsancionados,\&codCentroSancionado);
		my $primerCentro = codCentroSancionado($primerRegistro);#,\@TDAejecutados,\&centroEj);
		#print "Primer centro: $primerCentro \n";##################################################
		#darFormaControlDesdeSancionado($primerRegistro,$saldo_trimestral,$saldo_total,\%actividades);
		if ($primerCentro eq ""){
			return "";
		}
		while ( $primerCentro eq codCentroSancionado(&obtenerPrimerCentro(\@TDAsancionados,\&codCentroSancionado)) ){#,\@TDAejecutados,\&centroEj) ){
			
			
			#primero sancionados
			#agarro los registros y los pongo en un diccionario
			my %registros =();
			for my $refTDA(@TDAsancionados){
				if ( (finArchivo($refTDA) eq "no") 
					and 
				     (&codCentroSancionado(  obtenerRegistroActual($refTDA)) eq $primerCentro) 
				){
					$registros{obtenerRegistroActual($refTDA)}=$refTDA;
				}
			}
			my @regsSolos = keys %registros;
			
			#agarro el registro más reciente
			my $primerRegistro ="";
			foreach my $reg (@regsSolos){
				#print "vuelta\n";
				if( $primerRegistro eq ""){
					$primerRegistro = $reg;
				}else{
					my $triPrimer = trimestreSancionado($primerRegistro);
					my $triReg = trimestreSancionado($reg);
					my $vPrimer = trimestreAValor($triPrimer);
					my $vReg = trimestreAValor($triReg);
					if ($vPrimer > $vReg ){
						$primerRegistro = $reg;
					}
				}
			}
			if ($primerRegistro ne ""){
				#mostrar el registro más reciente
				#print "$primerRegistro\n";############################################################
				$saldo_trimestral = plataTotalSancionado($primerRegistro);
				#print "La plata total es $saldo_trimestral\n";
				$saldo_total += plataTotalSancionado($primerRegistro);
				darFormaControlDesdeSancionado($primerRegistro,$saldo_trimestral,$saldo_total,\%actividades,\%trimestres);
				
				#hacer avanzar el iterador del archivo para no volver a cargar ese registro
				&avanzarIterador($registros{$primerRegistro});
			}
			
			#luego ejecutado para ese centro, para ese trimestre
			my $primerTrimestre = trimestreSancionado($primerRegistro);
			sub filtroDoble{
				my $reg = shift;
				my $primerCentro = shift;
				my $primerTrimestre = shift;
				
				my $trimestre = trimestreEjecutado($reg);
				my $centro = codCentroEjecutado($reg);
				if ( ($centro eq $primerCentro) and ($trimestre eq $primerTrimestre) ){
					return "pasa";
				}else{
					return "saltear";
				}
			}
			
			my $pasa ="";
			do{
				$pasa = obtenerPrimeroQuePasa( \@TDAejecutados, \&filtroDoble, $primerCentro, $primerTrimestre, \&fechaEjecutado);
				$saldo_trimestral -= &dineroEjecutado($pasa);
				$saldo_total -= &dineroEjecutado($pasa);
				if ( $pasa ne ""){
					#print "$pasa\n";######################################################
					darFormaControlDesdeEjecutado($pasa,$saldo_trimestral,$saldo_total,\%actividades);
				}
			}
			while ( $pasa ne "" );
		}
	}
	
	#cerrarArchivos(\@TDAejecutados);
	#cerrarArchivos(\@TDAsancionados);
	
	return "";
}
sub cerrarArchivoTDA{
	my $refArchivo = shift;
	my @TDA = @{$refArchivo};
	close $TDA[1];
}
sub cerrarArchivos{
	my $refLista = shift;
	my @lista = @{$refLista};
	
	foreach my $arhivo (@lista){
		cerrarArchivoTDA($archivo);
	}
}
sub darFormaControlDesdeSancionado{
	
	my $sancionado = shift;
	my $saldo_tri = shift;
	my $saldo_acum = shift;
	my $refActividades = shift;
	my $refTrimestres = shift;
	my %hashTrimestres = %{$refTrimestres};
	
	my $centro = codCentroSancionado($sancionado);
	my $trimestre = trimestreSancionado($sancionado);
	my $codTrimestre = $hashTrimestres{$trimestre};
	my $control ="";
	#print "El registro sancionado q llega es $sancionado\n";
	print $archivoSalida "(++);$codTrimestre;$centro;0;$trimestre;$saldo_tri;$saldo_tri;$control;$saldo_acum\n";#acá falta poner la fecha de inicio del trimestre
}
sub darFormaControlDesdeEjecutado{
	my $ejecutado = shift;
	my $saldo_tri = shift;
	my $saldo_acum = shift;
	my $refActividades = shift;
	
	my $nombreAxc =  "$dirmae/tabla-AxC.csv";
	open(TABLA_AXC,"<$nombreAxc") or return "No existe el archivo $nombreAxc\n";
	
	my $id = idEjecutado($ejecutado);
	my $fecha = fechaEjecutado($ejecutado);
	my $centro =  codCentroEjecutado($ejecutado);
	my $actividad =  actividadEjecutado($ejecutado);
	my $trimestre =  trimestreEjecutado($ejecutado);
	my $importe =  dineroEjecutado($ejecutado);
	my $control =controlAxC(TABLA_AXC,$actividad,$centro,$refActividades);
	if (($saldo_tri < 0) or ($saldo_tri < 0) ){
		$control += " presupuesto excedido";
	}
	print $archivoSalida "$id;$fecha;$centro;$actividad;$trimestre;$importe;$saldo_tri;$control;$saldo_acum\n";
}
sub obtenerPrimeroQuePasa{
	my $refTDAs = shift;
	my $filtro = shift;
	my $primerCentro= shift;
	my $primerTrimestre = shift;
	my $valorador = shift;
	
	my @listaTDAs = @{$refTDAs};
	
	my @listaRegsPasan = ();
	my %hashRegsPasan =();
	foreach my $TDA (@listaTDAs){
		my $registro = obtenerRegistroActual($TDA);
		if ( &{$filtro}($registro, $primerCentro, $primerTrimestre) eq "pasa" ){
			push @listaRegsPasan, $registro;
			$hashRegsPasan{$registro} = $TDA;
		}
	}
	
	my $menorValorado ="";
	foreach my $reg (@listaRegsPasan){
		if( $menorValorado eq ""){
			$menorValorado = $reg;
		}else{
			my $valorMenor = &{$valorador}($menorValorado);
			my $valorReg =&{$valorador}($reg);
			if ($valorReg < $valorMenor){
				$menorValorado = $reg;
			}
		}
	}
	if ($menorValorado ne ""){
		avanzarIterador($hashRegsPasan{$menorValorado});
	}
	
	return $menorValorado;
}

sub obtenerPrimerCentro{
	if($#_ == 3){
		my $cA = obtenerPrimerCentro($_[0],$_[1]);
		my $cB = obtenerPrimerCentro($_[2],$_[3]);
		if( $cA lt $cB){
			return $cA;
		}else{
			return $cB;
		}
	}else{
		my $refTDAs = shift;
		my $filtro = shift;
		my @centros =();
		my %centroRegistro=();
		for my $refTDA (@{$refTDAs}){
			if ( finArchivo($refTDA) eq "no"){
				my $registro = obtenerRegistroActual($refTDA);
				my $centro = &{$filtro}($registro);
				$centroRegistro{$centro}=$registro;
				push @centros, $centro;
			}
		}
		
		sort @centros;
		my $centroRet = $centros[0];
		my $regRet = $centroRegistro{$centroRet};
		#return ($centroRet,$regRet);
		return $regRet;
	}
}

sub avanzarIterador{
	my $refTDA = shift;
	my $ret ="";
	
	my $largo = @$refTDA - 2;#la cantidad de cosas en refTDA menos el iterador y el fp
	my $iterador = ${$refTDA}[0];#el primero es el iterador
	
	if ($iterador < $largo){
		$iterador += 1;#avaza el iterador
		$ret = "cambio";
	}else{
		$ret = "fin";
	}
	${$refTDA}[0] = $iterador;
	
	return $ret;
}
sub obtenerRegistroActual{
	my $refTDA = shift;
	
	my $fp = ${$refTDA}[1];#el segundo es el fp
	my $iterador = ${$refTDA}[0];#el primero es el iterador
	my $posEnTDA=$iterador +2;
	
	my $posEnArchivo=${$refTDA}[$posEnTDA];
	
	my $leido = leerRegistro($posEnArchivo,$fp);
	return $leido;
}
sub finArchivo{
	my $refTDA = shift;
	
	my $ret ="";
	
	my $largo = @$refTDA - 2;#la cantidad de cosas en refTDA menos el iterador y el fp
	my $iterador = ${$refTDA}[0];#el primero es el iterador
	if ($iterador == $largo){
		#print "   ++$iterador $largo++   ";
		return "si";
	}else{
		#print "   --$iterador $largo--   ";
		return "no";
	}
}

sub avanzarIteradorFiltrando{
	my $refTDA = shift;
	my $filtro = shift;
	
	if ( finArchivo($refTDA) eq "si" ){
		return "";
	}
		
	while( ( hayQueSaltear($filtro,$refTDA) eq "saltear") and (finArchivo($refTDA) eq "no") ){
		avanzarIterador($refTDA);
	}
}
sub hayQueSaltear{
	my $registroActual = obtenerRegistroActual($_[1]);
	#print "El registro actual es $registroActual hayQueSaltear\n";
	my $resultadoChequeo = &{$_[0]}( $registroActual );
	#print "el resultado es $resultadoChequeo\n";
	return $resultadoChequeo;
}


sub avanzarIteradoresFiltrando{
	my $refTDAs=shift;
	my $filtro = shift;

	my @TDAs = @$refTDAs;
	foreach my $refTDA (@TDAs){
		avanzarIteradorFiltrando($refTDA, $filtro);
	}
}

sub archivosTerminados{
	my $refTDAs=shift;
	my @TDAs = @$refTDAs;
	
	
	foreach my $refTDA (@TDAs){
		if (finArchivo($refTDA) eq "no"){
			return "no";
		}
	}
	return "si";
}

#--------------------------------------------------EJECUTADO----------------------------------#
sub esAnio{
	my $anio = shift;
	if ( $anio !~ /^\d\d\d\d$/){
		return "No es un año valido, debe tener cuatro digitos.\n";
	}else{
		return "";
	}
}
sub esCtTc{
	my $opcion = shift;
	if ( ($opcion ne "ct") and ($opcion ne "tc") ){
		return "El orden debe ser tc o ct.\n";
	}else{
		return "";
	}
}

sub esActividadCargandoArchivo{
	my $actividad = shift;
	my %actividades = &parsearActividades;
	if ( esActividad($actividad,\%actividades) ){
		return "";
	}else{
		return "$actividad no es el nombre d euna actividad.\n";
	}
}
sub codigoDeActividad{
	my $actividad = shift;
	my $refActividades=shift;
	
	my %actividades=%$refActividades;
	my $codigo;
	foreach my $cod (keys(%actividades)){
		my $act =$actividades{$cod};
		if( $act eq $actividad){
			$codigo = $cod;
		}
	}
	
	return $codigo;
}
sub controlAxC{
	my $fp = shift;
	my $actividad = shift;
	my $centro = shift;
	my $refActividades=shift;
	
	my $codigo = codigoDeActividad($actividad,$refActividades);
	
	seek($fp,0,0);
	
	my $regex="$codigo;$centro";
	my $linea;
	while ($linea = <$fp>){
		chomp $linea;
		if($linea eq $regex){
			return "";
		}
	}
	return "gasto fuera de la panificacion";
}
sub ejecutado {
	#validaciones
	my $largo = @_;
	if($largo <= 1){
		return "Cantidad de argumentos errónea\n";
	}

	my $opcion = $_[0];
	if( esCtTc($opcion) ne ""){
		return "La primera opcion debe ser ct o tc, es $opcion.\n";
	}
	
	my $anio =$_[1];
	if(esAnio($anio) ne ""){ #porque queda lindo así
		return "La segunda opción debe ser un anio, es $anio\n";
	}
	
	#cargar actividades y centros
	my %actividades = &parsearActividades;
	my %centros = &parsearCentros;
	
	#constrir/validar filtros
	my @filtros =();
	if ($largo > 1 ){
		@filtros = @_[2..$#_];
	}
	
	foreach my $filtro (@filtros){
		if(not esActividad($filtro,\%actividades)){
			return "$filtro no es una actividad\n";
		}
	}
	
	#abrir el archivo de AxC
	my $nombreAxc =  "$dirmae/tabla-AxC.csv";
	open(TABLA_AXC,"<$nombreAxc") or return "No existe el archivo $nombreAxc\n";
	
	#abrir el archivo de ejecutado
	my $nombreEjecutado =  "$dirproc/ejecutado-$anio";#######################ES DIRPROC!!!!
	open(EJECUTADO,"<$nombreEjecutado") or return "No existe el archivo $nombreEjecutado\n";
	
	#armado del índice
	my @registros=indexarArchivo(EJECUTADO, $formaEjecutadoRx);
	
	
	#ordenado del indice
	my @ordenados = indiceOrdenado(
		EJECUTADO,
		$opcion,
		\@registros,
		\%centros,
		\&trimestreEjecutado,
		\&codCentroEjecutado,
		"nombre",
		\&cmpTrimestres
	);
	my $creditoFiscalAcumulado = dineroEjecutado($registro);
	print $archivoSalida "FECHA;CENTRO;NOM_CEN;COD_ACT;ACTIVIDAD;TRIMESTRE;GASTO;PROVINCIA;CONTROL\n";
	for (my $i =0; $i <=$#ordenados; $i++){
		my $registro = leerRegistro($ordenados[$i],EJECUTADO);
		my $actividadActual = actividadEjecutado($registro);
		my $centroActual = codCentroEjecutado($registro);
		if (pasaPorFiltros($actividadActual,\@filtros)){
			my $control = controlAxC(TABLA_AXC,$actividadActual,$centroActual,\%actividades);
			my $codAct = codigoDeActividad($actividadActual,\%actividades);
			&mostrarRegistroParaEjecutado($registro,$control,\%centros,$codAct);
			my $dinero = dineroEjecutado($registro);
			$creditoFiscalAcumulado += $dinero;
			#print "$registro;$control\n";
		}
	}
	print $archivoSalida ";;;;;Total Credito Fiscal;$creditoFiscalAcumulado;;\n";
	
	close TABLA_AXC;
	close EJECUTADO;
	return ""
	
}
sub mostrarRegistroParaEjecutado{
	my $registro = shift;
	my $control = shift;
	my $refCentros = shift;
	my $codAct = shift;
	
	my %centros = %{$refCentros};
	
	my $fecha = fechaEjecutado($registro);
	my $centro = codCentroEjecutado($registro);
	my $nomCen = $centros{$centro};
	
	my $actividad = actividadEjecutado($registro);
	
	my $trimestre = trimestreEjecutado($registro);
	
	my $gasto = puntoPorComa(dineroEjecutado($registro));
	my $provincia = provinciaEjecutado($registro);
	print $archivoSalida "$fecha;$centro;$nomCen;$codAct;$actividad;$trimestre;$gasto;$provincia;$control\n";
}
#-------------------------------------------------SANCIONADO----------------------------------#
sub parsearCentros {
	my $nombreCentros =  "$dirmae/centros.csv";
	my $pattern =qr/^([0-9.\-]*);([A-Za-z 0-9]*)$/;
	my $filtroClave = sub {
		my $matame=$_[0];
		$matame=~s/$pattern/$1/;
		return $matame;
	};
	my $filtroValor = sub {
		my $matame=$_[0];
		$matame=~s/$pattern/$2/;
		return $matame;
	};
	return hashDeArchivo($nombreCentros,$pattern,$filtroClave,$filtroValor);
}

sub sancionado {
	#validaciones
	my $largo = @_;
	if( $largo != 2 ){
		return "Cantidad de argumentos errónea";
	}

	my $opcion = $_[0];
	if( esCtTc($opcion) ne "" ){
		return "La primera opcion debe ser ct o tc";
	}
	
	my $anio =$_[1];
	if(esAnio($anio) ne ""){
		return "La segunda opción debe ser un anio";
	}
	
	#apertura del archivo
	my $nombreSancionados =  "$dirmae/sancionado-$anio.csv";
	open(SANCIONADO,"<$nombreSancionados") or return "No existe el archivo $nombreSancionados\n";
	
	#armado del índice
	my @registros=indexarArchivo(SANCIONADO, $formaSancionadoRx);
	
	#cargado del archivo de centros
	my %centros = &parsearCentros;

	#seleccion de categorizador y especificador
	#asumo tc
	my $categorizador= \&trimestreSancionado;
	my $especificador =sub { 
		my $arg = shift;
		my $codCen = &codCentroSancionado($arg);
		my $centro =$centros{$codCen};
		return $centro; 
	};
	if ($opcion eq "ct"){#intercambia criterios si asumí mal
		my $d =$categorizador;
		$categorizador = $especificador;
		$especificador = $d;
	}

	my @ordenados = indiceOrdenado(
		SANCIONADO,
		$opcion,
		\@registros,
		\%centros,
		\&trimestreSancionado,#####################33
		\&codCentroSancionado,############################
		"nombre",
		\&cmpTrimestres
	);

	

	#escritura con subtotales
	my $previ=0;
	print $archivoSalida "año presupuestario $anio;total\n";
	my $subtotal = 0;
	my $total=0;
	for (my $i=0; $i<=$#ordenados; $i++){
		my $regActual=leerRegistro($ordenados[$i]    ,SANCIONADO);
		my $regPrevio=leerRegistro($ordenados[$previ],SANCIONADO);
		
		my $categoriaActual = &{$categorizador}($regActual);
		my $categoriaPrevia = &{$categorizador}($regPrevio);
	
		if ($categoriaActual ne $categoriaPrevia){
			my $subtotalComa =puntoPorComa($subtotal);
			print $archivoSalida "Subtotal $categoriaPrevia; $subtotalComa\n\n";
			$subtotal = 0;
		}
		
		my $especifico = &{$especificador}($regActual);
		my $suma  = &plataTotalSancionado($regActual);
		my $sumaComa=puntoPorComa($suma);

		$subtotal += $suma;
		$total += $suma;
		
		print $archivoSalida "$especifico; $sumaComa\n";
		
		if ($i == $#ordenados){#si este es el último, también es el último de su bloque FEO, CAMBIAR PARA QUE MIRE EL SGTE
			my $subtotalComa =puntoPorComa($subtotal);
			print $archivoSalida "Subtotal $categoriaActual; $subtotalComa\n\n";
			$subtotal=0
		}
		
		$previ=$i;
	}
	
	my $totalConComa=puntoPorComa($total);
	print $archivoSalida "Total: $totalConComa\n";
	
	#cerrar archivo
	close SANCIONADO;
	
	return "";
};


#-------------------------------------------------AYUDA----------------------------------#

sub mostrarAyuda{
	my $l_ = @_;
	if ($l_ == 0){
		print "listep: procesador de listados.\nComandos disponibles:\n";
		foreach my $comando (keys(%comandos)){
			print "	$comando\n";
		}
		print "Para ver información sobre un comando utilice\n	listep ayuda <comando>\n"
	}else{
		print $comandos{$_[0]};
	}
	
};

sub ayuda{
	my $largo=@_;
	
	if ($largo == 0){
		&mostrarAyuda;
		return "";
	}
	
	if ($largo > 1){
		return "cantidad de argumentos errónea";
	}
	
	my $comando =@_[0];
	if(exists($comandos{$comando}) ){
		mostrarAyuda($comando);
		return "";
	}else{
		return "el comando $comando no existe";
	}
}

#---------------------------------------------------EJECUTAR COMANDO------------------------------#
sub ejecutarComando{
	my $nombreComando = $_[0];
	chomp($nombreComando);
	@_ = @_[1..$#_]; #saco el primer argumento
	
	#arma este hash al reves raro	
	my %invertido=();
	foreach $i (0...$#_){
		$invertido{$_[$i]} = $i;
	}
	
	#busca el -f, abre el archivo
	if( exists ($invertido{"-f"})){
		my $posicion = $invertido{"-f"};
		if (exists( $_[$posicion + 1] )){
			my $nombreArchivo = $_[$posicion + 1];
			@_=@_[0..$posicion-1]; #saco el -f y el nombre del archivo
			&cambiarArchivoSalida($nombreArchivo);
		}
	}

	#ejecutar el comando
	if ( exists($comandos{$nombreComando}) ){
		my $mensajeDeError = &{$nombreComando}(@_);
		if($mensajeDeError){ #en éxito hay que devolver un string vacío
			print $mensajeDeError."\n";
			&mostrarAyuda($nombreComando);
		}
	}else{
		print "ERROR: El comando no existe\n";
		&mostrarAyuda;
	}
}

sub cambiarArchivoSalida{
	my $nombre = shift;
	$nombre = $ENV{DIRINFO}."/".$nombre;
	open(ARCHIVOSALIDA,">$nombre") or die "FALLO LA APERTURA DEL ARCHIVO DESTINO $nombre\n";
	$archivoSalida=ARCHIVOSALIDA;
}

sub construirLlamada{ #también lo llama
	my $nombreComando = shift;
	
	my @listaArgumentos=($nombreComando);
	
	my $refArrayArgumentos=$argumentos{$nombreComando};
	my @arrayDeHashesDeArgumentos=@{$refArrayArgumentos};
	for (my $i=0; $i<=$#arrayDeHashesDeArgumentos; $i++){
		my $refHashArgumento = $arrayDeHashesDeArgumentos[$i];
		#perl te odio
		my %hashArgumento = %{$refHashArgumento};
		my $refValor=$hashArgumento{"valor"};
		my $esLista = $hashArgumento{"esLista"};
		if ($esLista == 1){
			my @valor = @{$refValor};
			push @listaArgumentos, @valor;
		}else{
			my $valor = ${$refValor};		
			push @listaArgumentos, $valor;
		}
	}
	
	return @listaArgumentos;
}

sub ejecutaComando{
	print "Modo de ejecución de comandos.\n";
	print "l:lista de comandos, <nombre del comando>: ejecutarlo, q:salir\n";
	while( <STDIN> ){
		chomp($_);
		if( $_ eq "l"){
			for my $comando (keys(%comandos)){
				print "	$comando\n";
			}
		}elsif ($_ eq "q"){
			return;
		}else {
			if( exists($comandos{$_}) ){
				my @listaArgumentos = &construirLlamada($_);
				ejecutarComando(@listaArgumentos);
			}else{
				print "El comando $_ no existe";
			}
		}
		
		print "l:lista de comandos, <nombre del comando>: ejecutarlo, q:salir\n";
	}
}

sub configurarArgumento{
	my $refHashArg = shift;
	
	my %hashArg = %{$refHashArg};
	
	%argCtTc=("explicacion" => "Cómo ordenar la salida. ct:ordenar por central y luego por trimestre. tc: lo opuesto",
	"validador"=>"esTcCt",
	"valor"=>\$ctTcDefault,
	"esLista"=>0,
	"nombre"=>"orden",
	);
	
	my $explicacion = $hashArg{"explicacion"};#
	my $validador = $hashArg{"validador"};
	my $refValor = $hashArg{"valor"};
	my $esLista = $hashArg{"esLista"};#
	my $nombre = $hashArg{"nombre"};#
	
	print "Configurando $nombre.\n$explicacion\n";
	
	if( $esLista == 1 ){
		print "el valor actual de $nombre es:\n";
		foreach my $val (@{$refValor}){
			print "	$val\n";
		}
		print "b: borrar todos los valores, <valor>:agregarlo al final, q:salir\n";
		
		while(<STDIN>){
			chomp($_);
			if ($_ eq "b"){
				@{$refValor}=();
			}elsif($_ eq "q"){
				return;
			}else{
				my $errorValidacion = &{$validador}($_);
				if ($errorValidacion eq ""){
					push @{$refValor}, $_;
				}else{
					print $errorValidacion;
				}
			}
			
			print "el valor actual de $nombre es:\n";
			foreach my $val (@{$refValor}){
				print "	$val\n";
			}
			print "b: borrar todos los valores, <valor>:agregarlo al final, q:salir\n";
		}
	}else{
		print "el valor actual de $nombre es: $$refValor\n";
		print "<valor>: cambiar el valor, q:salir\n";
		
		while(<STDIN>){
			chomp($_);
			if($_ eq "q"){
				return;
			}else{
				my $errorValidacion = &{$validador}($_);
				if ($errorValidacion eq ""){
					$$refValor = $_;
				}else{
					print $errorValidacion;
				}
				
			}
			print "el valor actual de $nombre es: $$refValor\n";
			print "<valor>: cambiar el valor, q:salir\n";
		}
	}
	
	
}

sub configurarComando{
	my $comando = shift;
	
	my $refArgumentos = $argumentos{$comando};
	my @argumentos = @{$refArgumentos};
	
	print "\nConfigurando el comando $comando.\n";
	print "Configurando $comando. l:lista de argumentos, <nombre del argumento>: configurarlo, q: salir\n";
	while( <STDIN> ){
		chomp($_);
		
		if( $_ eq "l"){
			for my $refArgumento (@argumentos){
				my %hashArgumento = %{$refArgumento};
				my $nombre = $hashArgumento{"nombre"};
				print "	$nombre\n";
			}
		}elsif ($_ eq "q"){
			return;
		}else {
			my $esArg = 0;
			my %hashArg=();
			for my $refArgumento (@argumentos){
				my %hashArgumento = %{$refArgumento};
				my $nombre = $hashArgumento{"nombre"};
				if ($nombre eq $_){
					$esArg = 1;
					%hashArg = %{$refArgumento};
				}
			}
			if( $esArg == 1){
				&configurarArgumento(\%hashArg);
			}
		}
		
		print "l:lista de argumentos, <nombre del argumento>: configurarlo, q: salir\n"
	}
}

sub configurar{
	print "En este menú se configuran los parámetros de los comandos\n";
	print "l:lista de comandos, <nombre del comando>: configurarlo, f: cambiar archivo de salida, q:salir\n";
	while( <STDIN> ){
		chomp($_);
		
		if( $_ eq "l"){
			for my $comando (keys(%comandos)){
				print "	$comando\n";
			}
		}elsif ($_ eq "q"){
			return;
		}elsif ($_ eq "f"){
			print "Ingrese un nombre de archivo\n";#//////////////////////////////////////////////IMPLEMNENTAR
			my $nombreArchivo =<STDIN>;
			&cambiarArchivoSalida($nombreArchivo);
		}else {
			if( exists($comandos{$_}) ){
				&configurarComando($_);
			}else{
				print "El comando $_ no existe";
			}
		}
		
		print "l:lista de comandos, <nombre del comando>: configurarlo, f: cambiar archivo de salida, q:salir\n";
	}
	
}
#----------------------------------------------------MAIN-----------------------------------------#
if ($lARGV == 0){
	print "Iniciando modo interactivo. Llame como listep ayuda para aprender sobre el modo normal\n";
	print "e:ejecutar un comando, c: configurar, q: salir\n";
	while ( <STDIN> ) {
		#switch( $_ ){
		#	case "e" {print "caca!"}
		#
		#}
		chomp($_);
		
		if ($_ eq "e"){
			&ejecutaComando;
		}elsif ($_ eq "c"){
			&configurar;
		}elsif ($_ eq "q"){
			print "saliendo del programa\n";
			exit 0;
		}
		print "e:ejecutar un comando, c: configurar, q: salir\n";
		
	}
}else{
	ejecutarComando(@ARGV)
}
close $archivoSalida;
